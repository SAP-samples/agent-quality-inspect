UNSUPERVISED_ERROR_SUMMARIZATION_PROMPT_TEMPLATE = """You are tasked with summarizing the error type in a concise and abstract manner based on the provided explanation. This explanation is generated by a judge model, which evaluates whether the agent’s response satisfies the specified subgoals. In the explanation, a grade of "C" (Complete) indicates success, while "I" (Incomplete) indicates failure.

Your goal is to produce an error type that:
    •	Clearly captures the core failure or issue at an abstract level.
    •	Avoids restating the explanation verbatim.
    •	Is short, specific, and phrased like a category label rather than a long sentence.
    •	Does not include sensitive details or unnecessary context.
    •	If the error type involves tool usage, explicitly include the tool name in the error type.

You will be provided with:
    •	Ground truth subgoals
    •	Judge model’s explanation of the agent’s response

[BEGIN DATA]
***
[Ground Truth Subgoals]: {subgoals}
***
[Explanation]: {explanation}
***
[END DATA]

Please return your output in the following **strict JSON format**:
{{
    "error_type": "<error_type>",
    "explanation": "<explanation>"
}}
"""

ERROR_SUMMARIZATION_OUTPUT_SCHEMA = {
    "type": "json_schema",
    "json_schema": {
        "name": "error_summarization_output_schema",
        "schema": {
            "type": "object",
            "properties": {
                "error_type": {"type": "string"},
                "explanation": {"type": "string"}
            },
            "required": ["error_type", "explanation"],
            "additionalProperties": False,
            "strict": True
        }
    }
}

MAJORITY_VOTE_PROMPT_TEMPLATE = """You are given multiple independent predictions of the same data row.  
Each prediction includes an error type assigned by a model.  
Your task is to determine the **most probable true error type** using a majority voting approach.

Instructions:
1. Review all provided error types carefully.
2. Group similar or semantically equivalent error types together, even if their wording differs.
3. Count how many times each grouped error type appears.
4. Select the error type with the highest count as the final result.
5. If there is a tie:
   - Prefer the error type that is more specific and informative.
   - If still tied, choose the one most consistent with the majority wording.
6. Output ONLY the most probable error type, without extra commentary.

[BEGIN DATA]
[Error Types]: {error_type_list}
[END DATA]

Please return your output in the following **strict JSON format**:
{{
    "most_probable_error_type": "<most_probable_error_type>"
}}
"""

MAJORITY_VOTE_OUTPUT_SCHEMA = {
    "type": "json_schema",
    "json_schema": {
        "name": "majority_vote_output_schema",
        "schema": {
            "type": "object",
            "properties": {
                "most_probable_error_type": {"type": "string"}
            },
            "required": ["most_probable_error_type"],
            "additionalProperties": False,
            "strict": True
        }
    }
}


CLUSTERING_PROMPT_TEMPLATE = """You are tasked with clustering the following error types based on their semantic similarity. The goal is to group related error types under broader, more abstract categories to reduce redundancy and improve generalization.

Important:
    •	The cluster_label should be primarily grounded in the <subgoals> provided.
    •	Only if you are very certain that an error type is entirely unrelated to the subgoals should you create a new cluster label not derived from them.
    •	Always aim to preserve the subgoal’s intent when naming clusters.

Guidelines:
    •	Error types are not mutually exclusive and may overlap in meaning.
    •	Each cluster should reflect the most abstract and inclusive label that unifies all error types within it.
     •	Do not merge error types referring to different tools into a single cluster.
    •	Clusters involving tool usage must be separated by tool name.
     •	The cluster_label for each tool-related cluster must explicitly include that tool’s name.
    •	Minimize the number of clusters while maintaining clear and meaningful distinctions.
    •	Avoid overly specific wording—cluster labels should be reusable in other contexts where the same subgoal applies.

[BEGIN DATA]
[Subgoals]: {subgoals}
[Error Types]: {error_types}
[END DATA]

Please return your output in the following strict JSON format:
{{
  "clusters": [
    {{
      "cluster_label": "<generalized_error_type>",
      "error_types": ["<error_type_1>", "<error_type_2>", ...],
      "error_ids": ["<error_id_1>", "<error_id_2>", ...]
    }},
    ...
  ]
}}
"""

CLUSTERING_OUTPUT_SCHEMA = {
    "type": "json_schema",
    "json_schema": {
        "name": "clustering_output_schema",
        "schema": {
            "type": "object",
            "properties": {
                "clusters": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "cluster_label": {"type": "string"},
                            "error_types": {"type": "array", "items": {"type": "string"}},
                            "error_ids": {"type": "array", "items": {"type": "string"}}
                        },
                        "required": ["cluster_label", "error_types", "error_ids"],
                        "additionalProperties": False,
                        "strict": True
                    }
                },
            },
            "required": ["clusters"],
            "additionalProperties": False,
            "strict": True
        }
    }
}
